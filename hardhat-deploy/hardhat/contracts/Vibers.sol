// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**


__     __ ______ _______  ________ _______   ______
|  \   |  \      \       \|        \       \ /      \
|▓▓   | ▓▓\▓▓▓▓▓▓ ▓▓▓▓▓▓▓\ ▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓\  ▓▓▓▓▓▓\
|▓▓   | ▓▓ | ▓▓ | ▓▓__/ ▓▓ ▓▓__   | ▓▓__| ▓▓ ▓▓___\▓▓
\▓▓\ /  ▓▓ | ▓▓ | ▓▓    ▓▓ ▓▓  \  | ▓▓    ▓▓\▓▓    \
 \▓▓\  ▓▓  | ▓▓ | ▓▓▓▓▓▓▓\ ▓▓▓▓▓  | ▓▓▓▓▓▓▓\_\▓▓▓▓▓▓\
  \▓▓ ▓▓  _| ▓▓_| ▓▓__/ ▓▓ ▓▓_____| ▓▓  | ▓▓  \__| ▓▓
   \▓▓▓  |   ▓▓ \ ▓▓    ▓▓ ▓▓     \ ▓▓  | ▓▓\▓▓    ▓▓
    \▓    \▓▓▓▓▓▓\▓▓▓▓▓▓▓ \▓▓▓▓▓▓▓▓\▓▓   \▓▓ \▓▓▓▓▓▓

credit to DerpyBirbs, Cosmic Caps, and Critterz for their input on this contract
!vibe

//TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
// Does ERC721A randomize mint?
// Audit contract for Reentrancy attacks


*/

contract Vibers is Ownable, ERC721A, ReentrancyGuardUpgradeable {

    uint256 internal PRICE = 0;

    // Constant Variables
    uint256 internal constant MAX_SUPPLY = 1000; //CHANGE TO 10,000 TODO
    uint256 internal constant MAX_MINTS_PER_TRANSACTION = 4;
    uint256 internal constant ALLOWLIST_MAX_MINT_PER_WALLET = 2;

    // Variables
    uint[MAX_SUPPLY] private indices;
    uint private nonce = 0;
    uint private numTokens = 0;

    // Minting Allowlist & Public list
    bool internal allowlistMintOpen = false;
    bool internal publicMintOpen = false;

    mapping(address => uint256) public allowlistMintedCounts;
    mapping(address => uint256) public publicMintedCounts;

    event allowlistMintOpened();
    event publicMintOpened();

    // Metadata Variables
    bytes32 internal _allowlistMerkleRoot;
    string internal _baseTokenURI;
    bool internal metadataLocked = false;
    uint internal devSupplyAwarded = 0;


    //  REMOVE TESTNET ADDRESSES BEFORE DEPLOYMENT ON MAINNET
    address payable internal developers = payable(0xf8e807027c4f6D0968C8c4742508D136D926A981);
    //  REMOVE TESTNET ADDRESSES BEFORE DEPLOYMENT ON MAINNET


    /**
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */

    constructor(string memory baseTokenURI, bytes32 allowlistMerkleRoot) ERC721A("Vibers", "VIBE") {
        _baseTokenURI = baseTokenURI;
        _allowlistMerkleRoot = allowlistMerkleRoot;
        //dont call awardDevs() here, initial supply here, too much gas for one transaction
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
    * Can only be called twice. Gives 64 total Vibers to developers for marketing purposes.
    * 28 of these will go to Treasure Chests holders.
    */

    function give32TokensToDevs() external onlyOwner {
        require(publicMintOpen == false,"Sale has already started");
        require(devSupplyAwarded < 64,"Dev supply has already been awarded");
        uint i;
        uint id;

        for(i = 0; i < 32; i++){
            id = randomIndex();
            _mint(developers, id);
            numTokens = numTokens + 1;
        }

        devSupplyAwarded = devSupplyAwarded+1;
    }

    /**
    * Credits to LarvaLabs Meebits contract
    */

    function randomIndex() internal returns (uint) {
        uint totalSize = MAX_SUPPLY - numTokens;
        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
        uint value = 0;

        if (indices[index] != 0) {
            value = indices[index];
        } else {
            value = index;
        }

        // Move last value to selected position
        if (indices[totalSize - 1] == 0) {
            // Array position not initialized, so use position
            indices[index] = totalSize - 1;
        } else {
            // Array position holds a value so use that
            indices[index] = indices[totalSize - 1];
        }
        nonce++;
        // Don't allow a zero index, start counting at 1
        return value+1;
    }

    /**
     * @dev Creates a new token. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     */

    function mint(uint256 quantity) external payable noContract {
        //check sale start
        require(publicMintOpen, "Sale has not started yet.");

        //Maximum of 10000 Vibers
        require(numTokens < MAX_SUPPLY, "Mint request exceeds total supply!");

        //mint at least one
        require(quantity > 0, "Must mint at least one.");

        //check max per transaction
        require(quantity <= MAX_MINTS_PER_TRANSACTION, "Mint exceeds limit per call.");

        //check for overmint
        require(quantity <= MAX_SUPPLY-numTokens,"Mint request exceeds current supply!");

        //check payment
        require(msg.value == PRICE * quantity, "msg.value invalid");

        _safeMint(msg.sender, quantity);

    }

    // #TODO Does this function need a minthelper?
    function allowlistMint(
      uint256 quantity,
      bytes32[] calldata allowlistProof
    ) external payable noContract onlyAllowlist(allowlistProof) {

        //Reentrancy vulnerablility? TODO
      uint256 allowlistMintedCount = allowlistMintedCounts[msg.sender];
      uint256 newAllowlistMintedCount = allowlistMintedCount + quantity;
      //check sale start
      require(allowlistMintOpen, "Allowlist minting closed");

      //Maximum of 10000 Vibers
      require(numTokens < MAX_SUPPLY, "Mint request exceeds total supply!");

      //mint at least one
      require(quantity > 0, "Must mint at least one.");

      //check max per transaction
      require(newAllowlistMintedCount <= ALLOWLIST_MAX_MINT_PER_WALLET, "Mint exceeds limit per call.");

      //check for overmint
      require(quantity <= MAX_SUPPLY-numTokens,"Mint request exceeds current supply!");

      //check payment
      require(msg.value == PRICE * quantity, "Vibers price mismatch");

      allowlistMintedCounts[msg.sender] = newAllowlistMintedCount;

      _safeMint(msg.sender, quantity);
    }

    function availableAllowlistMint(bytes32[] memory allowlistProof)
      external
      view
      returns (uint256)
    {
      if (_inAllowlist(allowlistProof)) {
        return ALLOWLIST_MAX_MINT_PER_WALLET - allowlistMintedCounts[msg.sender];
      } else {
        return 0;
      }
    }

    function _verify(
      bytes32[] memory proof,
      bytes32 root,
      address _address
    ) internal pure returns (bool) {
      return
        MerkleProof.verify(proof, root, keccak256(abi.encodePacked(_address)));
    }

    function _inAllowlist(bytes32[] memory proof) internal view returns (bool) {
      return _verify(proof, _allowlistMerkleRoot, msg.sender);
    }


    /*
     OWNER FUNCTIONS
    */

    /**
     * @dev Withdraws funds to dev and art teams
     */

    function withdrawFunds() external virtual {
        uint256 balance = address(this).balance;
        developers.transfer(balance);
    }

    /**
    * Devs cant change URI after the sale begins
    */

    function setBaseURI(string memory baseTokenURI) external onlyOwner {
        require(metadataLocked == false,"Cannot change metadata after the metadata is locked");
        _baseTokenURI = baseTokenURI;
    }

    /**
    * Start public sale (can't be stopped after called)
    */

    function setPublicMintOpen(uint256 _PRICE) external virtual onlyOwner {
      require(publicMintOpen == false, "Public mint has already started");
      require(allowlistMintOpen, "Allowlist mint must be started first");
      PRICE = _PRICE;
      publicMintOpen = true;
      emit publicMintOpened();
    }

    /**
    * Start allowlist sale (can't be stopped after called)
    */

    function setAllowlistMintOpen(uint256 _PRICE) external virtual onlyOwner {
      require(allowlistMintOpen == false, "Allowlist mint has already started");
      PRICE = _PRICE;
      allowlistMintOpen = true;
      emit allowlistMintOpened();
    }

    /**
    * Freeze the metaData
    */

    function lockMetadata() external virtual onlyOwner {
        require(publicMintOpen, "Public mint must be started first");
        require(metadataLocked == false, "Metadata is already locked");
        metadataLocked = true;
    }

    function getQuantityMinted() external view returns (uint256) {
        return numTokens;
    }

    function getMaxSupply() external pure returns (uint256) {
        return MAX_SUPPLY;
    }

    function getMintPrice() external view returns (uint256) {
        return PRICE;
    }

    function hasSaleStarted() external view returns (bool) {
        return allowlistMintOpen;
    }

    function hasPublicSaleStarted() external view returns (bool) {
        return publicMintOpen;
    }

    function hasMetadataFroze() external view returns (bool) {
        return metadataLocked;
    }

    function setMintPrice(uint256 _PRICE)
      external
      onlyOwner
    {
      require(allowlistMintOpen == true, "The sale must be started to change the existing price.");
      PRICE = _PRICE;
    }

    function setAllowlistMerkleRoot(bytes32 allowlistMerkleRoot)
      external
      onlyOwner
    {
      _allowlistMerkleRoot = allowlistMerkleRoot;
    }

    /*
    MODIFIER
    */

    modifier noContract() {
      address account = msg.sender;
      require(account == tx.origin, "Caller is a contract");
      uint256 size = 0;
      assembly {
        size := extcodesize(account)
      }
      require(size == 0, "Caller is a contract");
      _;
    }

    modifier onlyAllowlist(bytes32[] memory allowlistProof) {
      require(_inAllowlist(allowlistProof), "Caller is not allowlisted");
      _;
    }

}
